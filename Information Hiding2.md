## 정보은닉
=====

### 1. 캡슐화(Encapsulation) 
- 객체 지향 프로그래밍에서 데이터와 그 데이터와 관련된 함수를 하나의 단위(객체) 안에 포장하는 것(관련 데이터와 그 데이터를 조작 및 처리하는 메서드를 하나의 '클래스'로 결합시키는 것). 
- 클래스 내부의 데이터나 메서등에 대한 접근을 제한하는 것으로 객체 내부의 상세 구현을 숨기고, 오로지 외부에 제공할 인터페이스만 노출시킬 수 있음.
- public / protected / private 접근 제한자를 사용하여 공개 / 내부 사용 / 공유 금지 설정 제한이 가능함.

#### 캡슐화의 장점
- 내부 구현 변경의 용이성 : 객체의 내부 구현을 변경해도 외부에서는 그대로 사용 가능함. 인터페이스는 유지되면서 내부 구현만 변경할 수 있게 된다는 뜻.
- 유지 보수 : 클래스나 객체의 내부 구현에 문제가 생겼을 때, 해당 부분만 수정하면 되므로 유지 보수가 용이함.
- 오류 최소화 : 외부에서의 불필요한 접근이나 변경을 방지함으로써, 잘못된 데이터의 입력이나 메서드의 호출을 방지 가능.


### 2. 상속성(Inheritance)
- 한 클래스의 속성과 메서드를 다른 클래스가 상속받아 사용할 수 있게 하는 기능.

#### 상속성의 주요 개념 및 특징
1. 기본 클래스(부모클래스 / 슈퍼 클래스) : 다른 클래스에게 속성 혹은 메서드를 제공하는 클래스
2. 파생 클래스(자식 클래스 / 서브 클래스) : 기본 클래스의 속성과 메서드를 상속받는 클래스. 상속 받은 속성이나 메서드 외에도, 자체적인 추가 속성이나 메서드를 가질 수 있음.
3. 오버라이딩(Overriding) : 서브 클래스에서 슈퍼 클래스에 정의 된 메서드를 재정의 하는 것. 서브 클래스는 부모 클래스의 메서드를 자신의 요구에 맞게 수정하여 사용가능.
4. 다중 상속 : 일부 프로그래밍 언어에서는 하나의 클래스가 여러 개의 클래스로부터 상속 가능하다. 다만, 이럴 경우 다양한 문제점이 생길 수 있기 때문에, 일부 언어(Java 등)에서는 단일 상속만을 허용한다.

#### 상속의 장점 
- 코드 재사용 : 기존 클래스의 속성과 메서드를 새로운 클래스에서 재사용 가능하여 코드 중복을 줄일 수 있다.
- 확장성 : 기존 클래스를 수정하지 않고 새로운 기능이나 속성을 추가가능하다.
- 모듈화 : 공통된 기능이나 속성을 기본 클래스에 정의하고, 특화된 기능만을 파생 클래스에서 정의함으로써 코드를 모듈화 가능하다.


### 다이나믹 캐스트(dynamic_cast)
: 객체지향 프로그래밍에서 '상속 구조 내부에서' 다형성을 활용할 때 다운 캐스팅(downcasting)을 수행하기 위해 사용하며, **상속 구조에서 기본 클래승의 포인터 혹은 참조가 파생 클래스의 객체를 가리키는 경우(업캐스팅이 이루어지는 경우), 그 포인터나 참조르 ㄹ다시 파생 클래스 타입으로 안전하게 변환하기 위해 사용** 한다.

- 다형성을 활용하는 경우, 기본 클래스의 포인터 혹은 참조를 통해 파생 클래스의 객체를 가리킬 수 있지만, 때로는 파생 클래스의 특정 멤버나 메서드에 접근하기 위해 원래의 파생 클래스 타입으로 캐스팅할 필요가 생긴다. 
**위의 경우에 사용하는 것이 다이나믹 캐스트이다.**

#### 다이나믹 캐스트의 특징
1. 런타임 검사 : dynamic_cast는 런타임 시점에 캐스팅의 유효성을 검사한다. 만약 캐스팅이 유효하지 않다면, 포인터 타입의 경우 nullptr을 반환하고, 참조 타입의 경우 예외를 발생시킨다.
2. 다운캐스팅 : 기본 클래스 타입에서 파생 클래스 타입으로의 캐스팅에 주로 사용된다.
3. 가상 함수 : dynamic_cast를 사용하려면 기본 클래스에 가상 함수가 적어도 하나 있어야 한다. 이렇게 함으로써 RTTI(Runtime Type Identification)가 활성화되어 런타임에 객체의 타입을 확인할 수 있게 된다.

``` cpp
class Base {
   virtual void foo() {}
};
class Derived : public Base {
   void bar() {}
};

Base* basePtr = new Derived();
Derived* derivedPtr = dynamic_cast<Derived*>(basePtr);

if (derivedPtr) {
    derivedPtr->bar();
} else {
    // 캐스팅 실패
}
```

위 예시의 경우, Derived는 Base를 상속받는다. 
Base 클래스에는 가상 함수 foo()가 있어 dynamic_cast를 사용할 수 있다. 
dynamic_cast를 통해 basePtr을 Derived* 타입으로 안전하게 캐스팅하고, 성공적으로 캐스팅되었다면 Derived 클래스의 bar() 메서드를 호출할 수 있다.

dynamic_cast는 런타임에 유효성을 검사하기 때문에 다른 캐스트 연산자(예: static_cast)보다 느릴 수 있기 때문에, 성능이 중요한 경우에는 주의해서 사용해야 한다.


#### 업 캐스팅(Upcasting)
- 파생 클래스(자식 클래스)의 객체를 기본 클래스(부모 클래스)의 참조나 포인터로 변환하는 것.
- 파생 클래스는 기본 클래스의 모든 특성을 상속받기 때문에 항상 안전함.
- 업 캐스팅을 통해 다형성을 구현 가능. 즉, 기본 클래스 포인터나 참조를 사용하여 파생 클래스의 객체를 조작할 수 있다.

``` cpp
class Animal {
    void speak() { cout << "동물 소리" << endl; }
};
class Dog : public Animal {
    void bark() { cout << "멍멍!" << endl; }
};

Dog myDog;
Animal* animalPtr = &myDog;  // 업 캐스팅
```

#### 다운 캐스팅(Downcasting)
- 기본 클래스의 객체를 파생 클래스의 참조나 포인터로 변환하는 것을 의미합니다.
- 기본 클래스는 파생 클래스의 특정 특성을 알지 못하기 때문에 **항상 안전하지 않다.** 따라서 잘못된 다운 캐스팅을 수행하면 런타임 오류가 발생할 수 있다.
- 다운 캐스팅을 수행할 때, 일반적으로 dynamic_cast와 같은 안전한 캐스팅 연산자를 사용하여 런타임에 캐스팅의 유효성을 검사한다.

``` cpp
Animal* animalPtr = new Dog();
Dog* dogPtr = dynamic_cast<Dog*>(animalPtr);  // 다운 캐스팅

if (dogPtr) {
    dogPtr->bark();
}
```

#추가 예정
