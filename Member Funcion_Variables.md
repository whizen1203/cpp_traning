## 멤버 함수 및 변수에 대하여
=====

### 멤버 함수(Member function) : 객체 지향 프로그래밍에서 클래스나 구조체의 일부로 정의된 함수. 멤버 함수는 해당 클래스나 구조체의 인스턴스(객체)에 연관된 동작을 수행하는데 사용된다. 
#### C++에서는 멤버 함수(member funtion)이라고 부르지만, 여러가지 객체지향 프로그래밍 언어가 등장하면서 **클래스의 메서드(methods)라고 부르는 것이 일반화 되었다.**

#### 멤버 함수의 특징 : 
1. 정의 : 멤버 함수는 **클래스나 구조체 내부에서 정의된다.** 이 멤버 함수는 해당 클래스나 구조체의 객체를 통해서만 호출될 수 있다.
2. this 포인터 : 멤버 함수 내에서는 'this'라는 특별한 포인터를 사용 가능하다. **this 포인터는 현재 객체의 주소를 나타내며,** 이를 통해 객체의 다른 멤버 변수나 멤버 함수에 접근할 수 있다.
3. 접근 제어 : 멤버 함수는 public, private, protected와 같은 접근 제어 지시자를 사용하여 접근 가능한 범위를 제한 가능하다. 예를 들어, private으로 선언된 멤버 함수는 해당 클래스 외부에서는 호출할 수 없다.
4. 오버로딩 : 같은 이름의 멤버 함수를 여러 개 정의할 수 있다. 이를 **'함수 오버로딩'이라고 하며, 매개변수의 유형이나 개수에 따라 적절한 함수가 호출된다.**
5. 정적 멤버 함수 : static 키워드를 사용하여 멤버 함수를 정의하면, 이 함수는 클래스의 인스턴스 없이도 호출이 가능하다. 정적 멤버 함수 내에서는 정적 멤버 변수만 접근이 가능하며, this 포인터를 사용할 수 없다.


### 멤버 변수(Member Variables) : 객체 지향 프로그래밍에서 클래스나 구조체의 일부로 정의된 변수. 해당 클래스나 구조체의 객체가 가지는 속성이나 상태를 표현하는 데 사용된다.

#### 멤버 변수의 특징 : 
1. 정의 : 멤버 변수는 클래스나 구조체 내부에서 정의된다. 이 변수는 해당 클래스나 구조체의 객체와 연관되어 있으므로, 객체마다 멤버 변수의 값이 다를 수 있다.
2. 접근 제어 : 멤버 변수는 public, private, protected와 같은 접근 제어 지시자를 사용하여 접근 가능한 범위를 제한할 수 있다.
- private : 해당 클래스 내에서만 접근 가능하며, 외부에서는 접근 불가능.
- public : 어디에서든 접근 가능.
- protected : 해당 클래스 및 파생 클래스에서만 접근 가능.
3. 정적 멤버 변수(static member variable) : static 키워드를 사용하여 멤버 변수를 정의하면, 이 변수는 클래스의 모든 객체에 공통으로 사용되는 변수가 된다. 즉, 한 객체에서 변경한 값은 다른 객체에서도 그대로 반영.
4. 초기화 : 멤버 변수는 생성자 내에서 초기화하는 것이 일반적안 방법. C++11 이후로는 멤버 변수를 선언할 때 직접 초기값을 지정하는 것도 가능하다.


### 오버로딩(Overloading)
멤버 함수의 경우 일반 함수처럼 오버로딩을 하지만, 클래스 내부에서 하나의 이름(보통 함수 이름)을 가지면서도 다양한 매개변수를 취하는 여러 함수나 메소드다. 
- 사용하면 같은 이름의 함수나 메소드를 여러 개 정의할 수 있지만, 매개변수의 유형이나 개수는 달라야 한다. 
- 소멸자를 제외한 모든 멤버 함수는 오버로딩이 가능하다.

#### 오버로딩의 주요 특징  :

1. 이름의 재사용 : 함수나 메소드의 기능이 비슷할 때, 같은 이름을 사용하면 코드의 일관성이 유지되며 가독성이 향상된다.
2. 매개변수의 차이 : 오버로딩된 함수들은 **'함수 이름은 같지만', '매개변수의 개수나 유형이 달라야' 한다.** ***반환 유형만 다른 경우에는 오버로딩으로 간주되지 않는다.***
3. 호출 시 구분 : 함수를 호출할 때 전달되는 인수의 개수나 유형에 따라 컴파일러는 적절한 버전의 함수를 선택하여 실행한다.


##### 오버로딩 예시
```
#include <iostream>

class Print {
public:
    // 오버로딩된 멤버 함수들
    void show(int i) {
        std::cout << "정수: " << i << std::endl;
    }

    void show(double d) {
        std::cout << "실수: " << d << std::endl;
    }

    void show(char const *str) {
        std::cout << "문자열: " << str << std::endl;
    }
};

int main() {
    Print p;
    p.show(10);          // 정수: 10
    p.show(3.14);        // 실수: 3.14
    p.show("안녕하세요"); // 문자열: 안녕하세요
    return 0;
}
```

### 연산자 오버로딩(operator Overloading)
: 프로그래밍 언어에서 특정 연산자에 대한 사용자 정의 연산을 허용하는 기능. 기존의 연산자를 사용하여 사용자 정의 데이터 유형에 대한 연산이 가능하다. 객체 지향 프로그래밍에서 **클래스 또는 구조체의 멤버 함수로 구현될 수 있다.**

```cpp

Copy code
class Complex {
private:
    double real, imag;

public:
    Complex(double r, double i) : real(r), imag(i) {}

    // + 연산자 오버로딩
    Complex operator + (const Complex& obj) {
        Complex temp;
        temp.real = real + obj.real;
        temp.imag = imag + obj.imag;
        return temp;
    }
};
``` 
위 경우, 두 Complex 객체를 더할 때 + 연산자를 사용하면 operator + 함수가 호출되어 두 복소수를 더한 결과를 반환된다.

#### 연산자 오버로딩의 주의점:
1. 오버로딩된 연산자는 **그 연산자의 기본 의미를 왜곡해서는 안된다.**
2. 오버로딩의 남용은 코드의 가독성을 저하시킬 수 있다.
