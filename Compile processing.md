# 컴파일(Compile)에 대한 정리.
=====


## 정의 
- 인간이 이해할 수 있는 언어로 작성된 소스 코드(고수준 언어. C / Java / Python 등)를 CPU가 이해할 수 있는 언어(저수준 언어. 기계어)로 번역하는 작업.


### 컴파일 과정 
=====

![img](https://ifh.cc/g/LwwbA3.png)

컴파일은 4단계의 과정을 통해 이루어진다.
1. 전처리 과정(Pre-processing)
2. 컴파일 과정(Compilation)
3. 어셈블리 과정(Assembly)
4. 링킹 과정(Linking)

위 4단계를 묶어 '컴파일 과정', '빌드 과정'이라고 부르기도 하며, 컴파일 과정과 링킹 과정을 따로 분류하여 부루기도 한다.
보통 빌드 과정이라 부르면 컴파일 + 링킹.

TMI) 컴파일 과정에서 연쇄적으로 사용하는 개발도구들(전처리기-컴파일러-어셈블러-링커)를 묶어 '툴체인(Tool Chain)'이라고 부른다.

=====
=====
#### 1. 전처리 과정(Pre-processing)
=====

전처리 과정은 전처리기(Preprocessor)를 통해 소스 코드 파일(*.c)를 전처리화된 코드 파일인 (*.i)로 변환하는 과정이다. 

이 과정 중에 대표적으로 3가지 작업을 행한다.

- 1. 주석 제거 : 소스 코드를 해석하기 전 주석을 전부 제거한다.
- 2. 헤더 파일 삽입 : #include 지시문을 만나면 해당하는 헤더파일을 찾아 그 헤더 파일 내부의 모든 내용을 복사하여 소스 코드에 삽입한다. 
		**헤더 파일은 컴파일에 이용되지 않으며,** 소스 코드 파일 내에서 전부 복사된다. 
		해더 파일에 선언된 함수 원형은 후에 링킹 과정을 통해 실제로 함수가 정의되어 있는 오브젝트 파일(컴파일된 소스 코드 파일)과 결합한다.
-3. 매크로 치환 및 적용 : #define 지시문에 정의된 매크로를 저장하고 같은 문자열을 만나면 #define 된 내용으로 치환한다. 간단하게 말해 매크로 이름을 찾아서 정의한 값으로 전부 바꿔준다.


#### 2. 컴파일 과정(Compilation)
=====

컴파일 과정(Compilation)은 컴파일러(Compiler)를 통해 전처리화된 소스 코드 파일(*.i)을 어셈블리 파일(*.s)로 변환하는 과정. 
이 과정에서 **언어의 문법 검사**가 이루어지며, Static 영역(Data, BSS 영역)들의 메모리 할당을 수행한다.


#### 2_1. 컴파일러 구조
=====

컴파일러는 3단계로 구성되어 있다.

##### 1. 프론트 엔드(Front-End) : 
-----
**프론트 엔드는 언어 종속적인 부분을 처리**한다.

프론트 엔드는 일반적인 사용자들과 직접적으로 상호 작용하는 부분으로, 웹 개발의 맥락에서는 웹 브라우저에서 실행되는 HTML, CSS, JavaScript 등으로 구성된 부분을 의미한다.
주요 목적은 사용자 경험(UX, User eXperience)과 인터페이스(UI, User Interface)를 구현하며, 사용자의 요청을 백 엔드로 전달하고, 백 엔드에서 받은 응답을 사용자에게 표시하는 역할을 한다.

소스 코드가 해당 언어로 올바르게 작성되어 있는지 확인(어휘/구문/의미 분석)하고 미들엔드에 넘겨주기 위한 GIMPLE 트리(소스 코드를 트리 형태로 표현한 자료구조)를 생성하며, 
위 과정에서 C / C++ / Java와 같은 다양한 언어들이 각 언어에 맞게 처리된 후, 공통된 중간 표현(IR : Intermediate representation)인 GIMPLE 트리로 변환되므로 언어 종속적인 부분을 처리할 수 있다.



##### 2. 미들 엔드(Middle-End) : 
-----
**미들 엔드에서는 아키텍처의 '비종속적인 최적화'를 수행한다.**
아키텍처의 비종속적인 최적화란, **CPU 아키텍처가 무엇이든(arm, x86 등) 상관없이 할 수 있는 최적화**를 의미한다. 

미들 엔드는 프론트 엔드와 백 엔드 사이의 브릿지 역할을 한다. 이 용어는 모든 아키텍처에서 일반적이지 않지만, 때로는 어플리케이션 로직 또는 중간 계층을 의미하기도 한다. 
프론트 엔드에서 넘겨받은 GIMPLE 트리를 이용해 아키텍처의 비종속적인 최적화를 수행한 후, 백 엔드에서 사용하는 RTL(Register Transfer Language : 고급 언어와 어셈블리 언어의 중간형태)를 생성한다.

미들 엔드는 비즈니스 로직, 데이터 처리, 인증 및 권한 부여와 같은 기능을 수행할 수 있으며, 프론트 엔드와 백 엔드 사이의 통신을 쉽게 만드는 API(Application Programming Interface)를 제공하기도 한다. 



##### 3. 백 엔드(Back-End) : 
-----
**백 엔드에서는 아키텍처의 '종속적인 최적화'를 수행한다.**
아키텍처의 종속적인 최적화란, **아키텍처의 특성에 따라 최적화를 수행하는 것**을 의미한다. 같은 기능을 수행하는 명령어여도 CPU 아키텍처별로 더욱 효율적인 명령어로 대체하여 성능을 높이는 작업을 예로 들 수 있다. 

백 엔드는 서버, 어플리케이션, 데이터베이스 등의 시스템을 포함하며, 프론트 엔드 또는 미들 엔드로부터의 요청을 처리하는 역할을 한다. 
주요 기능은 데이터베이스 관리, 서버 로직 처리, 인증, 서버 설정 및 유지 관리, 데이터 처리 등이 있다.
백 엔드에서는 Python, Java, Ruby, Node.js, PHP 등 다양한 프로그래밍 언어와 프레임워크가 사용될 수 있다.

미들 엔드에서 넘겨받은 RTL을 이용하여 아키텍쳐 종속적인 최적화를 수행하고, 최적화가 완료되면, 어셈블리 코드를 생성한다. 아키텍쳐 종속적인 최적화를 수행하면, 해당 아키텍처만 이해할 수 있는 언어가 되기 때문에 아키텍처가 맞지 않으면, 어셈블리 코드를 해석할 수 없다.



##### 4. 어셈블리어 정의
-----
기계어는 다른 말로 명령어(Machine Instruction)이라고도 부르는 데, 명령어는 0과 1로 이루어진 이진수로 이뤄진 숫자로, CPU 종류마다 고유한 내용을 가지고 있다.

**'어셈블리어'는 이런 명령어를 사람이 이해 할 수 있도록 '부호화'한 것**으로 CPU 명령어(기계어)와 1대 1로 매칭된다.

많은 컴파일러가 앞서 설명한 세 단계의 구조를 따르고 있지만, 컴파일러마다 차이가 존재한다.

GNU에서 만든 C컴파일러인 gcc는 프론트엔드 / 미들엔드 / 백엔드 단계가 깔끔하게 분리되어 있지 않고 의존성이 존재한다. 그에 비해 오픈 소스 C 컴파일러인 Clang(프론트엔드) + LLVM(미들엔드, 백엔드)는 단계가 단계가 잘 분리되어 있다. 



=====
#### 3. 어셈블리 과정(Assembly)
=====

어셈블리 과정(Asssembly)은 어셈블러를 통해 어셈블리 파일(*.s)을 오브젝트 파일(*.o)로 변환하는 과정이다. 



##### 3_1, 오브젝트 파일(Object file) 정의
=====
어셈블리 코드는 사람이 알아 볼 수 없는 기계어로 변환되는 데, 그것을 오브젝트 코드(Object code)라고 부른다.

**오브젝트 코드로 구성된 파일을 오브젝트파일(Object file)**이라고 부르며, 이 오브젝트 파일은 특정한 포맷을 가진다.
오브젝트 파일 포맷 종류 : Win의 경우 PE(Portable Executable), Linux의 경우 ELF(Executable and Linking Format), Mac의 경우 Mach-0(Mach-Object)로 나눠진다.

##### 1. 오브젝트 파일 포맷(Object File Format)
-----

![img2](https://ifh.cc/g/nMGhj0.png)

1) 오브젝트 파일 헤더(Object File Header) : 오브젝트 파일의 기초 정보를 가지고 있는 헤더
2) 텍스트 섹션(Text Section) : 기계어로 변환된 코드가 들어있는 부분
3) 데이터 섹션(Data Section) : 데이터(전역 변수, 정적 변수)가 들어 있는 부분
4) **심볼 테이블 섹션(Symbol Table Section)** : 소스 코드에서 참조되는 심볼들의 이름과 주소가 정의되어 있는 부분이다. 
5) **재배치 정보 섹션(Relocation Information Section)** : 링킹 전까지 심볼의 위치를 확정할 수 없으므로 심볼의 위치가 확정나면 바꿔야 할 내용을 적어놓은 부분.
6) 디버깅 정보 섹션(Debugging Information Section) : 디버깅에 필요한 정보가 있는 부분.

Symbol은 함수나 변수를 식별할 때 사용하는 이름으로, **Symbol Table 안에는 오브젝트 파일에서 참고되고 있는 심볼 정보(이름, 데이터의 주소 등)을 가지고 있다.** 

이 때 오브젝트 파일의 심볼 테이블에는 해당 오브젝트 파일의 심볼정보만 가지고 있어야 하기 때문에, **다른 파일에서 참고되고 있는 심볼의 경우, 심볼 테이블에 저장할 수 없다.**


#### Ex) #include<stdio.h> 라이브러리를 이용해서 printf 함수를 사용하는 소스 코드 파일
![img3](https://ifh.cc/g/my093A.png)

위 소스 코드 파일을 컴파일 하면, 오브젝트 파일을 생성할 수 있다.

하지만, 이 오브젝트 파일은 파일 내부에 printf 함수를 구현한 내용이 없기 때문에, 독립적으로 실행할 수 없다.

위의 경우, 전처리 과정(Pre-processing)을 통해 #include<stdio.h>로부터 printf 함수의 원형을 복사했지만, printf를 구현한 내용은 포함되어 있지 않다. 즉, 심볼 테이블(Symbol Table)은 오브젝트 파일의 심볼만을 가지고 있을 뿐, 외부에서 참조하는 printf 함수에 대한 심볼 정보는 가지고 있지 않다.

그렇기에 위 오브젝트 파일을 실행하기 위해서는 **printf 함수를 사용하는 오브젝트 파일과 printf 함수를 구현한 오브젝트 파일(libc.a 라이브러리)를 연결시키는 작업이 필요하다.**
그런 과정을 **링킹 과정(Linking)이라고 부른다.**



#### 링킹 과정(Linking)
=====
링킹 과정은 링커(Linker)를 통해 오브젝트 파일(*.o)들을 묶어 실행 파일로 만드는 과정이다.
이 과정에서 오브젝트 파일들과 프로그램에서 사용하는 라이브러리 파일들을 링크하여 하나의 실행 파일을 만든다.

이 떄 라이브러리를 링크하는 방법에 따라 정적 링킹(Static Linking)과 동적 링킹(Dynamic Linking)으로 나눌 수 있다. 


##### 링커의 역할 : 심볼 해석(Symbol Resolution), 재배치(Relocation)
-----

1) 심볼 해석(Symbol Resolution)

심볼 해석은 **각 오브젝트 파일에 있는 심볼 참조를 어떤 심볼 정의에 연관시킬지 결정하는 과정** 이다.
여러 개의 오브젝트 파일에 같은 이름의 함수 또는 변수가 정의되어 있을 때 어떤 파일의 어떤 함수를 사용할지 결정한다.


2) 재배치(Relocation)

재배치는 오브젝트 파일에 있는 데이터의 주소나 코드의 메모리 참조 주소를 알맞게 배치하는 과정이다. 
링커가 컴파일러가 생성한 오브젝트 파일을 모아서 한나의 실행 파일을 만들 때, **각 오브젝트 파일에 있는 데이터의 주소나 코드의 메모리 참조 주소가 링커에 의해 합쳐진 실행 파일에서의 주소와 다르기 때문에 그것을 알맞게 수정해줘야 한다.** 

이를 위해 오브젝트 파일 안에 재배치 정보 섹셔(Relocation Information Section)이 존재한다. 

**링킹 과정에서 같은 세션끼리 합쳐진 후 재배치가 일어난다.**


![img4](https://ifh.cc/g/Ox1hfd.png)

오브젝트 파일 형식은 위 예시와 같이, 링킹 과정에서 링커가 여러 개의 오브젝트 파일들을 하나의 실행 파일로 묶을 때 필요한 정보를 효율적으로 파악할 수 있는 구조이다.

**링킹을 '하기 전' 오브젝트 파일** 을 '재배치 가능한 오브젝트 파일(Relocatable Object File)'이라고 부르고, 
**링킹을 '통해 만들어지는' 오브젝트 파일** 을 '실행 가능한 오브젝트 파일(Executable Object File)'이라고 부른다.
